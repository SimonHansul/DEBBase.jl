var documenterSearchIndex = {"docs":
[{"location":"#DEBBase.jl:-A-basis-for-Dynamic-Energy-Budget-modelling-in-Julia","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"DEBBase is a basic package to perform Dynamic Energy Budget Toxicokinetic-Toxicodynamic (DEB-TKTD) modelling in Julia.  It includes a number of submodules:","category":"page"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"The core of the package is formed by DEBBase.DEBODE and DEBBase.ABC.","category":"page"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"DEBODE defines a baseline DEB-TKTD model and provides the core functionality to run simulations.  ABC contains code for parameter estimation using Sequential Monte Carlo Approximate Bayesian Computation. ","category":"page"},{"location":"#DEBODE:-DEB-TKTD-model-as-system-of-ordinary-differential-equations","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBODE: DEB-TKTD model as system of ordinary differential equations","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.DEBODE]","category":"page"},{"location":"#DEBBase.DEBODE.DEBParamCollection","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.DEBParamCollection","text":"A DEBParamCollection contains global parameters glb and spc parameters spc (including TKTD-parameters). \nInitialize the default parameter collection with DEBParamCollection().\n\n\n\n\n\n","category":"type"},{"location":"#DEBBase.DEBODE.GlobalParams","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.GlobalParams","text":"GlobalParams contain the global parameters (simulated timespan t_max, nutrient influx rate Xdot_in, etc.)\n\n\n\n\n\n","category":"type"},{"location":"#DEBBase.DEBODE.ODEAgentParams","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.ODEAgentParams","text":"ODEAgentParams(spc::Union{AbstractParams,NamedTuple})\n\nODEAgentParams are subject to agent variability.  This is in contrast to SpeciesParams, which define parameters on the species-level.\n\n\n\n\n\n","category":"type"},{"location":"#DEBBase.DEBODE.SpeciesParams","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.SpeciesParams","text":"SpeciesParams contain population means of DEB and TKTD parameters.  Default values are roughly reproduce life-history of Daphnia minda (model currency mass carbon in Î¼gC) exposued to Azoxystrobin (mg/L). \nDEBBase.jl uses a hierarchical modelling approach where the SpeciesParams are  parameters which are common across all agents of a species,  and ODEAgentParams contain parameters which are specific for an individual. \nVariability is given by the zoom factor Z::Distribution, which is always applied to the surface-area specific ingestion rates  and can optionally propagate to parameters indicated in propagate_zoom::NTuple. \nZ is Dirac(1) by default, i.e. there is no agent variability in the default parameters. \n\n\n\n\n\n\n","category":"type"},{"location":"#DEBBase.DEBODE.Hbj-NTuple{6, Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.Hbj","text":"Hbj(H::Float64, X_emb::Float64, H_b::Float64, H_j::Float64, p_b::Float64, p_j::Float64)::Float64\n\nMautrity-driven metabolic acceleration from birth to maturity threshold H_j (metamorphosis).  We assume that some baseline parameter p has value p_b at birth and p_j at metamorphosis. Between birth and metamorphosis, the current value of p is the maturity-weighted mean of p_b and p_j.  Not used in the base model.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.Sdot-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.Sdot","text":"Somatic growth, accounting for the possibility of shrinking.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.Sdot_negative-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.Sdot_negative","text":"Negative somatic growth, assuming that the residual kappa-assimiliation flux and structure will be combined to pay somatic maintenance.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.Sdot_positive-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.Sdot_positive","text":"Positive somatic growth.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.apply_stressors!-NTuple{4, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.apply_stressors!","text":"apply_stressors!(du, u, p, t)\n\nApply stressors to baseline parameter values.  Temperature correction affects DEB rate parameters,  other stressors affect parameters according to their respective PMoA.  A direct interaction between temperature and chemical toxicity is currently not considered.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.calc_SL_max-Tuple{Union{AbstractSpeciesParams, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.calc_SL_max","text":"calc_SL_max(spc::Union{AbstractSpeciesParams,NamedTuple})::Float64\n\nCalculate maximum structural length slmax [m^(1/3)]\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.calc_S_max-Tuple{Union{AbstractSpeciesParams, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.calc_S_max","text":"calc_S_max(spc::AbstractParams)::Float64\n\nCalculate maximum structural mass smax [m]\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.clipneg-Tuple{Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.clipneg","text":"Clip negative values.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dA!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dA!","text":"Assimilation flux\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dC_W!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dC_W!","text":"dC_W!(\n    du::ComponentVector,\n    u::ComponentVector,\n    p::Union{AbstractParamCollection,NamedTuple},\n    t::Real\n    )::Nothing\n\nChange in external concentrations.  Currently simply returns zeros because time-variable exposure is not yet implemented. \n\nTODO: extend to account for time-variable exposure.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dD!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dD!","text":"Minimal toxicokinetics for scaled damage dynamics, assuming no enviornmental uptake by embryos.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dH!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dH!","text":"Maturation flux. \n\nMaturity is dissipated energy and can therefore not be burned to cover maintenance costs. \n\nCurrently there are no consequences for an organism not covering maturity maintenance.  If this turns out to be an issue, we might consider to add a damage pool D_H, where the amount of maturity maintenance that could not be covered is accumulated.  This might then lead to a fitness penalty depending on D_H, for example in the form of additional  mortality or embryonic hazard. \n\nSuch rules are however likely species-specific and should be evaluated in the light of a more precise problem definition.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dH_b!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dH_b!","text":"Update the current estimate of Hb.  The current estimate of maturity at birth is equal to current maturity for embryos,  and will be fixed to the current value upon completion of embryonic development. This way, we can obtain Hb as an implied trait for use during the simulation.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dI!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dI!","text":"dI!(\n    du::ComponentArray,\n    u::ComponentArray,\n    p::Union{AbstractParamCollection,NamedTuple},\n    t::Real\n    )::Nothing\n\nCalculate ingestion rate.  Embryos (X_emb <= 0) take up resources from the vitellus X_emb.  Juveniles and adults (X_emb > 0) feed on the external resource X_p. \n\nThe DEBBase model assumes that all state variables are given as mass (or a linearly proportional quantity).  As this includes structure, the ingestion rate scales with the structural mass S^23`.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dJ!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dJ!","text":"Maturity maintenance flux\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dM!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dM!","text":"Somatic maintenance flux\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dQ!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dQ!","text":"dQ!(\n    du::ComponentArray,\n    u::ComponentArray,\n    p::Union{AbstractParamCollection,NamedTuple},\n    t::Real\n    )::Nothing\n\nCalculation of the total dissipation flux, equal to the sum of maintenance costs and overheads paid for assimilation, mobilization, maturation, growth and reproduction.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dR!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dR!","text":"Reproduction flux.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dS!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dS!","text":"Somatic growth, including application of shrinking equation.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dS_max_hist!-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dS_max_hist!","text":"dS_max_hist!(\n    du::ComponentArray,\n    u::ComponentArray,\n    p::Union{AbstractParamCollection,NamedTuple},\n    t::Real\n    )::Nothing\n\nReference structure S_max_hist, which is used as a measure of energetic state.\n\nThis is the amount of structure an individual of the given age has under ideal conditions,  i.e. f = 1 and y_z = 1, with the exception of y_G.  Values of y_G != 1 are included in the calculation of S_max_hist, so that a slowing down of growth \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.dX_p!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.dX_p!","text":"Change in environmental resource abundance, simulating a chemostat.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.exposure-Tuple{Function, Union{AbstractParamCollection, NamedTuple}, Vector{Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.exposure","text":"exposure(simcall::Expr, C_Wvec::Vector{Float64}; kwargs...)\n\nSimulate exposure to a single stressor over a Vector of constant exposure concentrations C_Wvec. \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.functional_response-Tuple{ComponentArray, ComponentArray, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.functional_response","text":"functional_response(\n    du::ComponentArray,\n    u::ComponentArray,\n    p::AbstractParamCollection,\n    t::Real\n    )::Float64\n\nCompute scaled functional response f_X, assuming a Holling Type II relationship.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.individual_variability!-Tuple{Union{AbstractParams, NamedTuple}, Union{AbstractParams, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.individual_variability!","text":"individual_variability!(p::Ref{AbstractParams})\n\nInduce agent variability in spc parameters via zoom factor Z.  Z is sampled from the corresponding distribution given in p and assumed to represent a ratio between maximum structurel masses (not lengths),  so that the surface area-specific ingestion rate Idot_max_rel_0 scales with Z^(1/3) and parameters which represent masses or energy pools scales with Z.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.initialize_statevars-Tuple{Union{AbstractParamCollection, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.initialize_statevars","text":"initialize_statevars(p::AbstractParamCollection, pindt::ComponentVector{Float64})::ComponentArray\n\nFor initialization of ODE simulator, initialize the component vector of state variables, u, based on common oaraeter collection p.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.k_J!-Tuple{Union{AbstractSpeciesParams, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.k_J!","text":"k_J!(spc::Union{AbstractSpeciesParams,NamedTuple})::Nothing\n\nSet the maturity maintenance rate constant,  assuming that the cumulative investment into maturity maintenance  equals the cumulative investment into somatic maintenance (cf. DEBkiss book by Tjalling Jager).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.lifestage_callbacks-Tuple{}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.lifestage_callbacks","text":"We use callbacks to keep track of the current life stage, avoiding if/else statements in  the derivatives.  Each life stage is associated with an identically named auxiliary variable,  taking logical values to indicate whether this is the current life stage.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.replicates-Tuple{Function, Union{AbstractParamCollection, NamedTuple}, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.replicates","text":"replicates(simulator::Function, params::Union{NamedTuple,AbstractParamCollection}, nreps::Int64; kwargs...)\n\nPerform replicated runs of simulator with parameters params (simulator(params) has to be a valid function call).  Analogous to @replicates, but a bit more flexible.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.sig-NTuple{4, Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.sig","text":"function sig(     x::Float64,      xthr::Float64,     yleft::Float64,      y_right::Float64;      beta::Float64 = 1e16     )::Float6\n\nSigmoid switch function.  This can be useful to replace simple if-statements with a continuous function. \n\ny_left and y_right are the function values left and right of the threshold x_thr.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.simulator-Tuple{Union{AbstractParamCollection, NamedTuple}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.simulator","text":"simulator(     p::Union{AbstractParamCollection,NamedTuple};      model = DEBODE!,     alg = Tsit5(),     saveat = 1,     reltol = 1e-6,     AgentParamType::DataType = ODEAgentParams,     kwargs...)::DataFrame\n\nRun an ODE-based model. \n\nargs:\n\ntheta::Union{AbstractParamCollection,NamedTuple}: A parameter collection with defined global parameters (<: AbstractGlobalParams) and species parameters (<: AbstractSpeciesParams).\n\nkwargs:\n\nmodel = DEBODE!: Definition of the derivatives. A function form du!(du, u, p, t)::Nothing. See definition of DEBODE! in derivatives.jl for an example, or see docs and examples of DifferentialEquations.jl for more details.\nalg = Tsit5(): Algorithm to be used by solve function \nsaveat = 1: When or how often to save ODE solutions to output\nreltol = 1e-6: Relative tolerance of ODE solutions\nAgentParamType::DataType = ODEAgentParams: The data type that stores those parameters that are affected by individual variability. There has to be a corresponding constructor so that theta.agn = AgentParamType(theta.spc) works. \nkwargs...: Additional keyword argument are passed on to OrdinaryDiffEq.solve\n\nExample: \n\nsim = simulator(DEBParamCollection())\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.tempcorr!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.tempcorr!","text":"Calculate temperature correction coefficient according to Arrhenius equation.  See apply_stressor! for application of the temperature correction.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.y_Z_DamageAddition!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.y_Z_DamageAddition!","text":"Response to chemical stressors, assuming damage addition for mixtures. <br>\n\nThe PMoA-specific damage values for each stressor are added up,\n\nD_j = sum_z=1^nD_jz\n\n, and the response is caluclated assuming identical DRC parameters for all stressors.  Currently, there are no additional weight factors implemented (assuming that the model is fitted to single-substance data only).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.y_z_DamageAddition!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.y_z_DamageAddition!","text":"Response to chemical stressors, assuming damage addition for mixtures. \n The PMoA-specific damage values for each stressor are added up,\n\nD_j = sum_z=1^nD_jz\n\n, and the response is caluclated assuming identical DRC parameters for all stressors.  Currently, there are no additional weight factors implemented (assuming that the model is fitted to single-substance data only).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.y_z_IA!-Tuple{ComponentVector, ComponentVector, Union{AbstractParamCollection, NamedTuple}, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.y_z_IA!","text":"Response to chemical stressors, assuming independent action for mixtures.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DEBODE.@replicates-Tuple{Expr, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DEBODE.@replicates","text":"@replicates(simcall::Expr, nreps::Int64)\n\nPerform replicated runs of simcall, where simcall is a call to a simulator function. \n\nExample:\n\n    spc = SpeciesParams(Z = Truncated(Normal(1, 0.1), 0, Inf)) # initialize default parameters with variable zoom factor\n    sim = @replicates DEBBase.simulator(DEBParamCollection(spc = spc))) 10 # execute replicated runs to simulator\n\nIn this case, sim will contain the output of 10 replicated simulations. For each replicate, the zoom factor is sampled from a truncated Normal distribution.  sim contains an additional column replicate.\n\n\n\n\n\n","category":"macro"},{"location":"#ABC:-Parameter-inference-using-Sequential-Monte-Carlo-Approximate-Bayesian-Computation","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"ABC: Parameter inference using Sequential Monte Carlo Approximate Bayesian Computation","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.ABC]","category":"page"},{"location":"#DEBBase.ABC","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC","text":"Submodule for parameter estimation using approximate bayesian computation.\n\n\n\n\n\n","category":"module"},{"location":"#Base.Iterators.zip-Tuple{DEBBase.ABC.Priors}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"Base.Iterators.zip","text":"zip(priors::Priors)\n\nSimultaneously iterate over parameter names and prior distributions.\n\n\n\n\n\n","category":"method"},{"location":"#Base.get-Tuple{DEBBase.ABC.Priors, Symbol}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"Base.get","text":"get(priors::Priors, param::Symbol)\n\nGet prior distribution from priors object. \n\nExamples:\n\nprior_kM = get(priors, :k_M)\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{DataType, DEBBase.ABC.Priors}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"Base.rand","text":"rand(defaultparams::DataType, priors::Priors)\n\nSample from priors and assign to new instance of default parameter structure.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.SMC-Tuple{Union{DEBBase.ABC.Priors, Tuple{DEBBase.ABC.Priors, DataFrame}}, Vararg{Any, 4}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.SMC","text":"SMC(\n    priors::Union{Priors,Tuple{Priors,DataFrame}},\n    defaultparams,\n    simulator,\n    distance,\n    data::Any;\n    n_pop::Int64 = 1000,\n    q_eps::Float64 = 0.2,\n    k_max::Int64 = 3,\n    convergence_eps::Float64 = 0.1,\n    paralellization_type = threaded,\n    savetag = \"smc\",\n    saveto::Union{String,False} = \"\"\n    )\n\nkwargs \n\nconvergence_eps::Float64 : we consider SMC converged if the relative difference between two successive distance thresholds Ïµ is less than convergence_eps\nsavedata::Bool : whether to include the value of positional argument data in the output metadata. false by default\nsaveto::Bool : where to store the SMCResult object on disc. tempname() by default.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.assign!-Tuple{AbstractParams, Symbol, Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.assign!","text":"assign!(particle::AbstractParams, paramname::Symbol, value::Float64; assignment_instructions::Nothing)\n\nAssign a sample to a param struct.  This accounts for the possibility that some parameters might be stored in vectors (e.g. TKTD parameters where each vector element corresponds to a chemical).  If kwarg assignment_instructions is Nothing, we can ignore it.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.assign!-Tuple{AbstractParams, Union{Vector{String}, Vector{Symbol}}, Union{DataFrameRow, AbstractVector}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.assign!","text":"assign!(particle::AbstractParams, paramnames::Union{Vector{Symbol},Vector{String}}, pvals::Union{AbstractVector,DataFrameRow})\n\nAssign new values to a parameter structure, given a list of names and values.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.bestfit-Tuple{AbstractParams, AbstractDataFrame}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.bestfit","text":"bestfit(defparams::AbstractParams, accepted::AbstractDataFrame)\n\nGet the best fit from accepted (particle with minimum distance) and assign to a copy of defparams.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.calcscale-Tuple{Vector{Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.calcscale","text":"Calculate quantile-based parameter scale for scalar parameters.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.calculatescales-Tuple{Int64, Vector{Symbol}, Vector{Vector{Float64}}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.calculatescales","text":"Calculate perturbation kernel scales from a Vector of accepted particles.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.calculateweights_threaded-Tuple{Vector{Vector{Float64}}, DEBBase.ABC.Priors, Vector{Symbol}, Vector{Vector{Float64}}, Vector{Int64}, Vector{Float64}, AbstractVector}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.calculateweights_threaded","text":"Calculate SMC sampling weights.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.deflognorm-Tuple{Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.deflognorm","text":"deflognorm(modus, sigma)\n\nDefine a truncated normal distribution based on the mode and Ï.  The parameter Î¼ is then calculated as mu = ln(mode) + sigma^2.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.deftruncnorm-Tuple{Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.deftruncnorm","text":"deftruncnorm(mu, CV; l = 0, u = Inf)\n\nDefine a truncated normal distribution based on the mean and CV.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.extractfields-Tuple{Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.extractfields","text":"Extract fields from a parameter structure.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.gaussiankernel-NTuple{4, Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.gaussiankernel","text":"gaussiankernel(old_value::Float64, scale::Float64, min::Float64, max::Float64)\n\nDefine a Gaussian perturbation kernel.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.getfieldname-Tuple{Symbol}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.getfieldname","text":"getfieldname(paramname::Symbol)::Symbol\n\nExtract a valid param struct fieldname from a parameter name by dropping the suffix. \n\nExamples\n\ngetfieldname(:k_D_A_1) # returns :k_D_A\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.getparindex-Tuple{Symbol}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.getparindex","text":"getparindex(paramname::Symbol)::Int64\n\nInfer index from a parameter name.\n\nExamples\n\ngetparindex(:k_D_G_1) # returns 1, because parameter name ends on _1\ngetparindex(:k_D_G) # will fail, because no index indicated in suffix\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.iman_conover-Tuple{Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.iman_conover","text":"iman_conover(ar, cor_mat)\n\nInduce rank correlations to independent samples, using Iman-Conover algorithm.  This function was adopted from the MCHammer package.  â- **MCHammer was released with the following License statement: **\n\nCopyright 2019-2021, Technology Partnerz Ltd. and Eric Torkia \n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.initialize_threaded-Tuple{Int64, Union{AbstractParamCollection, AbstractParams}, DEBBase.ABC.Priors, Any, Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.initialize_threaded","text":"initialize(     n_pop::Int64,      defaultparams::Union{AbstractParams,AbstractParamCollection},      priors::Priors,     simulator,     distance,     data::AbstractDataFrame     )\n\nInitialization of a population if the priors are purely parameteric priors.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.initialize_threaded-Tuple{Int64, Union{AbstractParamCollection, AbstractParams}, Tuple{DEBBase.ABC.Priors, DataFrame}, Any, Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.initialize_threaded","text":"initialize(\n    n_pop::Int64, \n    defaultparams::AbstractParams, \n    priors::Tuple{Priors,DataFrame},\n    simulator,\n    distance,\n    data::AbstractDataFrame\n)\n\nInitialization of the SMC population if the given priors are a combination of parameteric priors and previously accepted particles. \nNote that parameteric prior distributions should always be given for all parameters.  For the parameters which also appear in the dataframe of accepted values\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.isvecparam-Tuple{Symbol, AbstractParams}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.isvecparam","text":"isvecparam(paramname::Symbol, particle::AbstractParams)::Bool\n\nCheck whether parameter represents a Vector element.  We assume that the indices of such parameters are indicated by a suffix following the form  param_i. E.g. k_D_G_1 for the first value in the vector of k_D_G-values.  isvecparam checks whether such a field occurs in AbstractParams and whether it is a subtype of AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.posterior_sample!-Tuple{AbstractParams, DataFrame}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.posterior_sample!","text":"Take posterior sample from a data frame of accepted values and assign to parameter structure.  ID cols are at the end of the data frame and will be omitted from the sample, according to num_idcols.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.posterior_sample-Tuple{DataFrame}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.posterior_sample","text":"posterior_sample(accepted::DataFrame; reserved_colnames::Vector{String} = [\"distance\", \"weight\", \"model\", \"chain\"])\n\nTake posterior sample from a data frame of accepted values.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.ppc-Tuple{DEBBase.ABC.SMCResult}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.ppc","text":"ppc(fit::SMCResult; n_samples = 1000, kwargs...)\n\nRun a posterior predictive check, given SMCResult object fit.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.ppc-Tuple{Union{AbstractParamCollection, AbstractParams}, Any, AbstractDataFrame, DEBBase.ABC.Priors}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.ppc","text":"ppc(defaultparams::AbstractParams, simulator, accepted::AbstractDataFrame, priors::Priors; n_samples = 1000)\n\nCompute posterior predictions for posterior predictive check.\n\ndefaultparam::AbstractParams: default parameters used in simulator\nsimulator: simulator function with signature simulator(defaultparams, priors.params, sample), where \naccepted::AbstractDataFrame: accepted particles as returned by SMC\n\nThis function assumes that simulator returns a DataFrame.\n\nkwargs\n\nn_samples = 1000: number of samples from accepted_particles to evaluate\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.pvec-Union{Tuple{P}, Tuple{Vector{P}, Symbol}} where P<:AbstractParams","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.pvec","text":"Given parameter param, convert vector of parameter structures containg param into vector of values of param.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.rand!-Tuple{AbstractParams, DEBBase.ABC.Priors}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.rand!","text":"Sample from priors and assign to existing instance of parameter structure.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.resample-Tuple{Vector{Vector{Float64}}, Vector{Float64}, Vector{Float64}, DEBBase.ABC.Priors, Int64, Vector{Symbol}, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.resample","text":"resample(\n    accepted_particles::Vector{Vector{Float64}}, \n    accepted_distances::Vector{Float64},\n    accepted_weights::Vector{Float64},\n    priors::Priors,\n    n_pop::Int64,\n    parnames::Vector{Symbol},\n    num_params::Int64\n    )\n\nResample from previously accepted particles, with account for SMC sampling weights.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.summarize_accepted-Tuple{D} where D<:AbstractDataFrame","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.summarize_accepted","text":"summarize_accepted(\n    accepted::D; \n    ffun = fround\n    ) where D <: AbstractDataFrame\n\nCompute summary statistics from a data frame of accepted particles.  Values are formatted using function ffun. \n\nUse ffun = x - x to suppress any kind of formatting.  By default, values are rounded to 2 significant digits and formatted as strings using fround.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.wkde-Tuple{DataFrame, Symbol}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.wkde","text":"function wkde(accepted::DataFrame, param::Symbol)\n\nCompute a weighted kernel density estimate for parameter param in accepted particles accepted.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.wkde-Union{Tuple{Matrix{R}}, Tuple{R}, Tuple{Matrix{R}, Any}} where R<:Real","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.wkde","text":"function wkde(X::Matrix{R}, Ï = Vector{R}) where R <: Real\n\nCompute a weighted kernel density estimate on Matrix X.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.ABC.wkde-Union{Tuple{Vector{R}}, Tuple{R}, Tuple{Vector{R}, Any}} where R<:Real","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.ABC.wkde","text":"wkde(X::Vector{R}, Ï = Vector{R}) where R <: Real\n\nCompute a weighted Kernel Density Estimate of values in X with weights Ï. \n\n\n\n\n\n","category":"method"},{"location":"#DoseResponse:-A-collection-of-Dose-Response-functions","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DoseResponse: A collection of Dose-Response functions","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.DoseResponse]","category":"page"},{"location":"#DEBBase.DoseResponse.CRS4-Tuple{Float64, NTuple{4, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS4","text":"4-parameter CRS model. Lower limit and response in the control are fixed to 0 and 1, respectively.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS4U-Tuple{Float64, NTuple{4, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS4U","text":"4-parameter CRS model transformed to u-shape, where the response in the control is 1, the lower limit is 0 and the maximum is 2.0.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS5US-Tuple{Float64, NTuple{5, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS5US","text":"Re-scaled U-shaped CRS model with parameter C fixed to 0. \nParameters are \n- alpha: rate of hormetic increase\n\nb: slope of the inclining part of the curve\nd: maximum stress \ne: inflection point of the inclining part of the curve\nf: hormesis parameter\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS5US-Tuple{Vector{Float64}, NTuple{5, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS5US","text":"\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS6-Tuple{Float64, NTuple{6, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS6","text":"Cedergreend-Ritz-Streibig model. \nParameters are \n- p[1] = Î± = rate of hormetic increase\n\np[2] = b = quasi-slope\np[3] = c = lower limit\np[4] = d = response in the control\np[5] = e = inflection point\np[6] = f = hormesis parameter\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS6U-Tuple{Float64, NTuple{6, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS6U","text":"6-parameter U-shaped CRS model.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.CRS6US-Tuple{Float64, NTuple{6, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.CRS6US","text":"Re-scaled 6-parameter U-shaped CRS model.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2","text":"Two-parameter log-logistic function.  The expression y = 1 / (1 + (x/p[1])^p[2]) is extended to  y = (1 / (1 + Complex(x/p[1])^p[2])).re.  This way we deal with domain errors which might occur if x or p[1] temporarily takes a negative value.  Negative values should theoretically be impossible, but very small values of x (<= 1e-20) might occur during ODE solving.  In this case, the returned real part of the expression evaluates to 1, which is in turn the expected behaviour.  \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2M-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2M","text":"Two-parameter log-logistic function transformed to increasing function  for application to PMoA maintenance costs.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2M-Tuple{Vector{Float64}, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2M","text":"\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2h-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2h","text":"Cumulative hazard function of the log-logistic distribution. Mainly used for application in GUTS.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2hinv-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2hinv","text":"Inverse of the cumulative hazard two-parameter log-logistic function.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LL2inv-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LL2inv","text":"Inverse of the two-parameter log-logistic function.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LLAS3-Tuple{Float64, Tuple{Float64, Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LLAS3","text":"Asymmetric log-logistic function with additional slope parameter. Arguments:     - p1 = EC50     - p2 = beta     - p3 = beta_2\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.LLBP5-Tuple{Float64, NTuple{5, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.LLBP5","text":"Bi-phasic log-logistic function, where each phase is described by a two-parameter log-logistic function.  Requires additional \"breakpoint\" parameter. Arguments:     - p1 = EC501     - p2 = beta1     - p3 = EC502     - p4 = beta2     - p5 = breakpoint = relative response at which second phase starts\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.NEC2neg-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.NEC2neg","text":"Decreasing NEC model.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.NEC2pos-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.NEC2pos","text":"Increasing NEC model.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.WB2-Tuple{Float64, Tuple{Float64, Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.WB2","text":"Two-parameter Weibull function.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.DoseResponse.contmax-Tuple{Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.DoseResponse.contmax","text":"Continuous maximum function, using a sigmoid function to determine the maximum.\n\n\n\n\n\n","category":"method"},{"location":"#Figures:-Recipes-and-utilities-for-plotting-model-output","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"Figures: Recipes and utilities for plotting model output","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.Figures]","category":"page"},{"location":"#DEBBase.Figures","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Figures","text":"Recipes and convenience functions for plotting model output.\n\n\n\n\n\n","category":"module"},{"location":"#DEBBase.Figures.gridxattr-Tuple{Any, Any, Int64, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Figures.gridxattr","text":"gridxattr(attr, nullattr, numrows::Int64, numcols::Int64)::Matrix{String}\n\nAnalogous to gridyattr.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Figures.gridyattr-Tuple{Any, Any, Int64, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Figures.gridyattr","text":"Assign some attribute value attr to the left-most column of a multi-plot and  another attribute value nullattr to  all other subplots.\n\nExample:\n\nusing Plots, Plots.Measures\n# sets the left left column margin to 2.5mm and the other ones to 0mm\nplot(plot(), plot(), plot(), leftmargin = gridyattr(2.5mm, 0mm, 1, 3), layout = (1,3)) \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Figures.gridylabel-Tuple{AbstractString, Int64, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Figures.gridylabel","text":"Create shared y-labels for plot with grid layout, placing labels only on the left-most subplots.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Figures.saveplt-Tuple{Any, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Figures.saveplt","text":"Save plot plt with name, assuming known global TAG and plotsdir.\n\n\n\n\n\n","category":"method"},{"location":"#ParamStructs:-Infrastructure-to-organize-parameter-structures","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"ParamStructs: Infrastructure to organize parameter structures","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"By default, DEBBase uses mutable structs to store parameters. <br>","category":"page"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.ParamStructs]","category":"page"},{"location":"#Utils:-Other-utility-functions","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"Utils: Other utility functions","text":"","category":"section"},{"location":"","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","text":"Modules = [DEBBase.Utils]","category":"page"},{"location":"#DEBBase.Utils.C2K-Tuple{Float64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.C2K","text":"Convert degrees Celsius to Kelvin.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.diffvec-Tuple{AbstractVector}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.diffvec","text":"diffvec(x::AbstractVector)\n\nCalculate difference along a vector, inserting NaN as first element (analogous to Pandas' diff method).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.drop_na!-Tuple{DataFrame}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.drop_na!","text":"drop_na!(df::DataFrame)::Nothing\n\nMutating version of drop_na\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.drop_na-Tuple{AbstractDataFrame}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.drop_na","text":"drop_na(df::AbstractDataFrame; verbose=false)::DataFrame\n\nDrop all rows with missing values from data frame.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.extract_colnames-Tuple{ComponentVector}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.extract_colnames","text":"extract_colnames(u::ComponentVector)\n\nExtract the column names of an output dataframe from an ODE solution object.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.extract_colnames-Tuple{SciMLBase.ODESolution}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.extract_colnames","text":"extract_colnames(sol::O)::Vector{Symbol} where {O <:ODESolution}\n\nExtract the column names of an output dataframe from an ODE solution object.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.fround-Tuple{Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.fround","text":"fround(x; sigdigits=2)\n\nFormatted rounding to significant digits (omitting decimal point when appropriate).  Returns rounded number as string.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.geomrange-Tuple{Real, Real}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.geomrange","text":"geomrange(a::Real, b::Real; length=50)\n\nGeometric series created from two extreme values.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.geomrange-Tuple{Vector{Float64}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.geomrange","text":"geomrange(v::Vector{Float64}; length=50)\n\nGeometric series created from range of values within a vector.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.get_treatment_names-Tuple{Vector{Vector{Float64}}, Vector{Symbol}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.get_treatment_names","text":"get_treatment_names(exposure::Vector{Vector{Float64}}, stressor_names::Array{Symbol,1})\n\nInfer treatment types (categorical), levels (ordinal) and names (type + level) from Array of exposure concentrations.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.getstat-Tuple{DataFrame, String}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.getstat","text":"getstat(data::Vector{DataFrame}, statistic::String)\n\nRetrieve the mean of a statistic from a data frame with columns  \"statistic\" (listing different kinds of summary statistics) and \"value\".\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.idcol!-Tuple{AbstractDataFrame, Symbol, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.idcol!","text":"idcol!(sim::AbstractDataFrame, col::Symbol, val)\n\nAdd identifier column with name col and value val to results DataFrame sim\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.idcol!-Tuple{Any, Symbol, Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.idcol!","text":"idcol!(sim::Any, col::Symbol, val)\n\nAdd identifier column to a results object sim, assuming that sim is some collection of DataFrames (e.g. Tuple, Vector).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.into!-Tuple{AbstractParams, AbstractParams}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.into!","text":"into!(sink::AbstractParams, source::AbstractParams)::Nothing\n\nPut values from source into sink. \n\nsource::AbstractParams: A param struct from which we want to extract all parameters.\nsink::AbstractParams: All values from sink will be assigned to corresponding fields of sink.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.into-Tuple{DataType, AbstractParams}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.into","text":"into!(sink::AbstractParams, source::AbstractParams)\n\nPut values from source into sink. \n\nsource::AbstractParams: A param struct from which we want to extract all parameters.\nSink::DataType: All values from sink will be assigned to a new instance of type Sink, assuming that a constructor Sink() exists.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.ismin-Union{Tuple{Vector{R}}, Tuple{R}} where R<:Real","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.ismin","text":"Get positions of minimum values as BitVector.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.isolate_pmoas-Tuple{AbstractParams, Vector{String}, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.isolate_pmoas","text":"isolate_pmoas(spc::AbstractParams, pmoas::Vector{String}, z::Int64)::AbstractParams\n\nIsolate the indicated PMoAs for chemical stressor z.  That means, turn off all PMoAs (including lethal effects h) except for those indicated in pmoas-Vector.  This is done through the toxicokinetic rate constant.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.lab-Union{Tuple{Vector{R}}, Tuple{R}} where R<:Real","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.lab","text":"lab(v::Vector{R}; kwargs...) where R <: Real\n\nCreate legend labels from Vector of numeric Values.  Kwargs are handed down to fround. \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.read_W3C-Tuple{AbstractString}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.read_W3C","text":"read_W3C(file_path::AbstractString; kwargs...)::DataFrame\n\nRead a csv including W3C-formatted metadata. Each line with metadata starts with a hashtag (#). For example:\n\n#t: time in days\n#W: wet weight in grams\n\nt,W\n0,0.1\n1,0.2\n2,0.3\n\nAdditional kwargs are handed down to CSV.File. The function currently returns just the core data.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.relative_response-Union{Tuple{D}, Tuple{D, Vector{Symbol}, Symbol}} where D<:AbstractDataFrame","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.relative_response","text":"Calculate the relative responses. \n\nPositional arguments: \n\nsim::AbstractDataFrame: results\nresponse_vars::Vector{Symbol}: response variables for which to calculate the relative responses\ntreatment_var::Symbol: Column indicating the treatment. Column values can be numerical or categorical, but identify_control kwarg has to be specified in the latter case\n\nKeyword arguments: \n\ngroupby_vars::Vector{Symbol}: relative response will be conditioned on these variables (e.g. time, separate experiments...). Empty by default.\nidentify_control: function used to identify reference values from treatment_var. By default, this is minimum() (assuming that column values in treatment_var are numerical).\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.replace_na!-Tuple{AbstractDataFrame, Vector{Symbol}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.replace_na!","text":"replace_na!(\n    df::AbstractDataFrame,\n    cols::Vector{Symbol};\n    replace_val = 0.0\n    )\n\nReplace all missing values in DataFrame with replace_val.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.rr-Union{Tuple{R}, Tuple{R, R}} where R<:Real","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.rr","text":"Calculate relative response, given scalar values.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.set_equal!-Union{Tuple{SS}, Tuple{AbstractParams, SS, SS}} where SS<:Union{String, Symbol}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.set_equal!","text":"Set parameters with common prefix to the value of a reference parameter.  E.g. \n\nset_equal!(spc, :Idot_max_rel, :lrv)\n\nsets all parameters whose names start with Idot_max_rel equal to Idot_max_rel_lrv.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.skipinf-Tuple{Array}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.skipinf","text":"Skip inifite values. \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.sol_to_df-Tuple{O} where O<:SciMLBase.ODESolution","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.sol_to_df","text":"Convert ODE solution object to output data frame.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.sol_to_mat-Tuple{O} where O<:SciMLBase.ODESolution","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.sol_to_mat","text":"sol_to_mat(sol::O)::Matrix{Float64}\n\nConvert ODE solution object to matrix.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.trim!-Tuple{AbstractParams}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.trim!","text":"trim!(spc::AbstractParams)\n\nTrim TKTD parameters to the smallest number of stressors indicated for any PMoA. For example k_D_G = [1., 0.], k_D_M = [1.] will be trimmed to k_D_G = [1.], k_D_M = [1.].\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.vectify-Tuple{Any}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.vectify","text":"Parse String to Vector of Floats.\n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.which_in-Tuple{String, Vector{String}}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.which_in","text":"Identify element of possibilities occuring in x. \nE.g., which_in(\"I like apples\", [\"apples\", \"bananas\"]) returns \"apples\". \nIf multiple possibilities occur, first detection is returned. \n\n\n\n\n\n","category":"method"},{"location":"#DEBBase.Utils.wrappend-Tuple{String, DataFrame, Int64}","page":"DEBBase.jl: A basis for Dynamic Energy Budget modelling in Julia","title":"DEBBase.Utils.wrappend","text":"wrappend(file::String, data::DataFrame, step::Int64)\n\nWrite DataFrames to disc during loop. Will overwrite existing file if step == 1 and append if step > 1.\n\n\n\n\n\n","category":"method"}]
}
